<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../assets/css/styles.css">
    <link rel="stylesheet" href="../assets/css/cards.css">
    <title>DevAnnotation</title>
</head>
<body>
    <header>
        <div class="textAlignCenter">
            <a class="return" href="../index.html"><h3>Voltar</h3></a>
            <h1><a href="#">JavaScript Intermediário</a></h1>
        </div>
    </header>
    <div class="selectSection">
        <h5>
            <p class="textAlignCenter">Tópicos do Módulo</p>
            <a href="#topicOne">- Funções</a>
            <a href="#topicTwo">- Prototype</a>
            <a href="#topicThree">- Class</a>
            <a href="#topicFour">- Desestruturação</a>
            <a href="#topicFive">- Rest e Spred</a>
            <a href="#topicSix">- Métodos e Prop... String</a>
            <a href="#topicSeven">- Métodos e Prop... Array</a>
            <a href="#topicEigth">- Operações com Array</a>
            <a href="#topicNine">- Métodos e Pro... Função</a>
            <a href="#topicTen">- Métodos e Pro... Objeto</a>
            <a href="#topicEleven">- Métodos e Pr... Number</a>
            <a href="#topicTwelve">- Escopo</a>
            <a href="#topicThirteen">- Promise, Then e Catch</a>
            <a href="#topicFourteen">- Fetch</a>
            <a href="#topicFifteen">- JSON</a>
            <a href="#exercise">- Página de Exercícios</a>
        </h5>
    </div>
    <main>
        <section id="topicOne">
            <h2>Funções:</h2>
            <p>
                São blocos de código projetados para realizar uma tarefa específica. Elas podem ser reutilizadas em qualquer parte do seu 
                código e ajudam a organizar, modularizar e manter o código mais limpo e eficiente.
            </p>
            <h4>Function Declaration;</h4>
            <p>
                É o tipo mais comum e tradicional de função em JavaScript. Ela é definida usando a palavra-chave "function", seguida do nome 
                da função, parâmetros e o corpo da função. É hoisted, podendo ser chamada antes de sua definição no código.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>function functionDeclaration (x) {</pre>
                    <pre>   console.log('function declaration', x);</pre>
                    <pre>}</pre><br>
                    <pre><span class="comment">// Uso:</span></pre>
                    <pre>functionDeclaration('valor'); <span class="comment">// 'function declaration valor'</span></pre>
                </code>
            </div>
            <h4>Function Expression;</h4>
            <p>
                É uma expressão que define uma função e a atribui a uma variável. Geralmente anônima, pois a função não exige nomenclatura.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const functionExpression = function(x) {</pre>
                    <pre>   console.log('function expression', x);</pre>
                    <pre>}</pre><br>
                    <pre><span class="comment">// Uso:</span></pre>
                    <pre>functionExpression('valor'); <span class="comment">// 'function expression valor'</span></pre>
                </code>
            </div>
            <h4>Arrow Function;</h4>
            <p>
                Introduzida no ECMAScript 6 (ES6) e oferece uma sintaxe mais compacta para escrever funções. Geralmente anônima.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const arrowFunction = (x) => {</pre>
                    <pre>   console.log('arrow function', x);</pre>
                    <pre>}</pre><br>
                    <pre><span class="comment">// Ou</span></pre>
                    <pre>const arrowFunction = () => console.log('arrow function', x);</pre><br>
                    <pre><span class="comment">// Uso:</span></pre>
                    <pre>arrowFunction('valor'); <span class="comment">// 'arrow function valor'</span></pre>
                </code>
            </div>
            <h4>Factory Function;</h4>
            <p>
                É uma função que cria e retorna um único objeto quando chamada. Ela é flexível, já que pode retornar qualquer tipo de objeto.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>function factoryFunction(nome) {</pre>
                    <pre>	return {</pre>
                    <pre>		logou: () => alert(`O usuário ${nome} logou`),</pre>
                    <pre>		deslogou: () => alert(`O usuário ${nome} deslogou`),</pre>
                    <pre>	}</pre>
                    <pre>}</pre><br>
                    <pre><span class="comment">// Uso:</span></pre>
                    <pre>factoryFunction('João').logou(); <span class="comment">// 'O usuário João logou'</span></pre>
                    <pre>factoryFunction('João').deslogou(); <span class="comment">// 'O usuário João deslogou'</span></pre>
                </code>
            </div>
            <h4>Constructor Function;</h4>
            <p>
                É semelhante a Factory Function, pois é responsável por criar e retornar um objeto, porém esse pode criar mais de um objeto e 
                atribuir a eles características (atributos) herdáveis.
            </p>
            <div class="card">
                <span class="comment"> [ js ]</span>
                <code>
                    <pre>function Pessoa(nome, idade) {</pre>
                    <pre>	this.nome = nome</pre>
                    <pre>	this.idade = idade</pre>
                    <pre>	this.apresenteSe = function() {</pre>
                    <pre>		console.log(`Me chamo ${nome} e tenho ${idade} anos de idade.`)</pre>
                    <pre>	}</pre>
                    <pre>}</pre><br>
                    <pre>const pessoa1 = new Pessoa('João', 25); <span class="comment">// Cria um primeiro objeto</span></pre>
                    <pre>const pessoa2 = new Pessoa('Maria', 20); <span class="comment">// Cria um segundo objeto</span></pre><br>
                    <pre>pessoa1.apresenteSe(); <span class="comment">// 'Me chamo João e tenho 25 anos de idade.'</span></pre>
                    <pre>pessoa2.apresenteSe(); <span class="comment">// 'Me chamo Maria e tenho 20 anos de idade.'</span></pre>
                </code>
            </div>
        </section>
        <section id="topicTwo">
            <h2>Prototype:</h2>
            <p>
                O prototype é o principal mecanismo no JavaScript responsável pela herança de propriedades entre objetos. Todo objeto/função 
                no JS tem por padrão a propriedade prototype, que pode ser utilizada para armazenar outras proprieadades/métodos herdáveis 
                entre objetos do mesmo tipo.
            </p>
            <h4>Por que passar uma propriedade ou método através do prototype ao em vez de diretamento no construtor?</h4>
            <p>
                Quando um objeto é criado o JS armazena uma cópia das propriedades do construtor na instância, ou seja, a cada novo objeto um 
                novo código é duplicado. O que não ocorre se passado pelo método prototype, pois a herança permitirá que os objetos acessem 
                os métodos definidos nas camadas anteriores e os executem com base nos seus dados. Tornando o código mais eficiente e 
                escalável.
            </p>
            <h4>Exemplo de Utilização:</h4>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>function Carro(marca, modelo, ano) {</pre>
                    <pre>	this.marca = marca;</pre>
                    <pre>	this.modelo = modelo;</pre>
                    <pre>	this.ano = ano;</pre>
                    <pre>}</pre><br>
                    <pre>Carro.prototype.mostrarInfo = () => `Marca: ${this.marca}, Modelo: ${this.modelo}, Ano: ${this.ano}`</pre>
                    <pre><span class="comment">// Os objetos herdam a propriedade se haver duplicação de código</span></pre><br>
                    <pre>let meuCarro = new Carro('Toyota', 'Corolla', 2020);</pre><br>
                    <pre>console.log(meuCarro.mostrarInfo()); <span class="comment">// Marca: Toyota, Modelo: Corolla, Ano: 2020</span></pre>
                </code>
            </div>
        </section>
        <section id="topicThree">
            <h2>Class:</h2>
            <p>
                Pode-se dizer que as classes em JavaScript são uma versão melhorada da funções construtoras padrão, eles foram implementadas 
                no ECMAScript 6, sua utilidade principal é facilitar a orientação a objeto no JS.
            </p>
            <h4>Vantagens e Usos:</h4>
            <p>
                Suas vantagens são: sintaxe mais limpa, leve e moderna e herança simplificada (com "extends", ao em vez da manupulação por 
                "prototype"). Na classe quando existem métodos que só podem ser usados pelo construtor utilizar o termo "static" para privar. 
                Já quando existem dois métodos com a mesma nomenclatura e funcionalidades nas classes extendida e extensora, o método da 
                classe extendida será a executada, pois o metodo da extensora foi sobrescrito, se deseja manter a herança basta escrever 
                "super.metodo{}" e não passar um método com o mesmo nome na classe extendida.
            </p>
            <h4>Exemplo de Utilização:</h4>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>class Mamifero {</pre>
                    <pre>constructor(nome, idade) {</pre>
                    <pre>		this.nome = nome;</pre>
                    <pre>		this.idade = idade;</pre>
                    <pre>	}</pre>
                    <pre>	dormir() {</pre>
                    <pre>		alert(`${this.nome} dormiu.`);</pre>
                    <pre>	}</pre>
                    <pre>}</pre><br>
                    <pre>class Pessoa extends Mamifero {</pre>
                    <pre>	constructor(nome, idade, cpf) {</pre>
                    <pre>        super(nome, idade);</pre>
                    <pre>		this.cpf = cpf;</pre>
                    <pre>	}</pre><br>
                    <pre>    	static funcaoEstaticaQualquer() {</pre>
                    <pre>        	return "Função Estática Qualquer"</pre>
                    <pre>    	}</pre><br>
                    <pre>	falar() {</pre>
                    <pre>		alert(`Eu sou ${this.nome}, tenho ${this.idade} anos de idade e meu CPF é ${this.cpf}.`)</pre>
                    <pre>	}</pre>
                    <pre>}</pre><br>
                    <pre>let mamifero = new Mamifero('Panda', 15);</pre>
                    <pre>let pessoa = new Pessoa('João', 22, 29876543210);</pre><br>
                    <pre>mamifero.dormir(); <span class="comment">// Panda dormiu.</span></pre>
                    <pre>pessoa.dormir(); <span class="comment">// João dormiu.</span></pre>
                    <pre>pessoa.falar(); <span class="comment">// Eu sou João, tenho 22 anos de idade e meu CPF é 29876543210.</span></pre>
                </code>
            </div>
        </section>
        <section id="topicFour">
            <h2>Desestruturação:</h2>
            <p>
                A desestruturação é basicamente uma nova maneira de acessar as proprieadades de um objeto ou itens de um array. Sua 
                utilização consiste na simplicidade e reutilização de código.
            </p>
            <h4>Desestruturação em Objetos:</h4>
            <p>Sua forma de acesso é através do nome da propriedade como variável de objeto.</p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const pessoa = {</pre>
                    <pre>   nome: 'Diogo',</pre>
                    <pre>   idade: 20,</pre>
                    <pre>   altura: undefined,</pre>
                    <pre>   endereco: {</pre>
                    <pre>       estado: 'Ceará',</pre>
                    <pre>       cidade: 'Brejo Santo'</pre>
                    <pre>   }</pre>
                    <pre>}</pre><br>
                    <pre>const {nome, idade} = pessoa;</pre>
                    <pre>const {altura = 1.74} = pessoa; </pre>
                    <pre>const {estado, cidade} = pessoa.endereco;</pre><br>
                    <pre>console.log(nome); <span class="comment">// Diogo</span></pre>
                    <pre>console.log(altura); <span class="comment">// 1.74</span></pre>
                    <pre>console.log(estado); <span class="comment">// Ceará</span></pre>
                </code>
            </div>
            <h4>Desestruturação em Arrays:</h4>
            <p>Sua forma de acesso é semelhante ao de objetos, porém pela sua posição no array, definida por vígulas.</p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>cosnt carros = ['Hilux', 'HB20', 'Corola'];</pre><br>
                    <pre>const [, segundoCarro] = carros;</pre>
                    <pre>const [, , terceiro] = carros;</pre><br>
                    <pre>console.log(segundoCarro); <span class="comment">// HB20</span></pre>
                    <pre>console.log(terceiro); <span class="comment">// Corola</span></pre>
                </code>
            </div>
        </section>
        <section id="topicFive">
            <h2>Rest e Spred:</h2>
            <p>São duas ferramentas no JavaScript que auxiliam na programação e deixam a escrita do código mais limpa.</p>
            <h4>Rest:</h4>
            <p>
                Permite pegar todos os argumentos dos parametros de uma função, juntando todos em um único array ou objeto, deixando a 
                escrita do código mais simples. Sua nomenclatura é "..." + "nomeArrayObjeto".
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Array</span></pre>
                    <pre>function estados(ce, ...estados){ <span class="comment"> // Recebe dois paramentros "Ce" e o resto do array</span></pre>
                    <pre>	console.log(ce);</pre>
                    <pre>	console.log(estados);</pre>
                    <pre>};</pre>
                    <pre>estados('CE', 'RJ', 'SP', 'RR', 'SC');</pre>
                    <pre><span class="comment">// CE</span></pre>
                    <pre><span class="comment">// ['RJ', 'SP', 'RR', 'SC']</span></pre><br>
                    <pre><span class="comment">// Objeto</span></pre>
                    <pre>function pessoa(first, last, ...info) {</pre>
                    <pre>	console.log(first + last);</pre>
                    <pre>	console.log(info); <span class="comment">// Diogo22</span></pre>
                    <pre>};</pre><br>
                    <pre>const infoPessoa = {nome: 'Diogo', idade: 22, profissao: 'Programador', cidade: 'Brejo Santo', estado: 'CE'};</pre>
                    <pre>pessoa(infoPessoa); <span class="comment"></pre>
                    <pre><span class="comment">// Diogo22</span</pre>
                    <pre><span class="comment">// {profissao: 'Programador, cidade: 'Brejo Santo', estado: 'CE'}</span</pre>
                </code>
            </div>
            <h4>Spred:</h4>
            <p>
                Serve basicamente para destribuir as propriedades de um objeto ou itens de um array em outro. Assim como Rest sua 
                nomenclatura também é "..." + "nomedoArrayObjeto", mas agora ele adicionar dentro de outro Objeto ou Array.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Array</span></pre>
                    <pre>const carrosAltos = ['Hilux', 'S10', 'Pajero', 'ranger'];</pre>
                    <pre>const carrosBaixos = ['HB20', 'Gol', 'Celta', 'Corsa'];</pre>
                    <pre>const carros = [...carrosAltos, ...carrosBaixos]; <span class="comment">// Pegando todos os carros e adicionando em carros.</span></pre><br>
                    <pre>console.log(carros); <span class="comment">// ['Hilux', 'S10', 'Pajero', 'ranger', 'HB20', 'Gol', 'Celta', 'Corsa']</span></pre><br>
                    <pre><span class="comment">//Objeto</span></pre>
                    <pre>const pessoa = {</pre>
                    <pre>	nome: 'Diogo',</pre>
                    <pre>	idade: 22</pre>
                    <pre>};</pre>
                    <pre>const info = {</pre>
                    <pre>	profissao: 'Programador',</pre>
                    <pre>	cidade: 'Brejo Santo',</pre>
                    <pre>	estado: 'CE'</pre>
                    <pre>};</pre>
                    <pre>const dados = {</pre>
                    <pre>	...pessoa,</pre>
                    <pre>	altura: 1.74,</pre>
                    <pre>	...info</pre>
                    <pre>};</pre><br>
                    <pre>console.log(dados); <span class="comment">// {nome: 'Diogo', idade: 22, altura: 1.74, profissao: 'Programador, cidade: 'Brejo Santo', estado: 'CE'}</span></pre>
                </code>
            </div>
            <p>Rest e Spred compartilha da mesma nomenclatura, o que diferenciam a forma como são utilizados.</p>
        </section>
        <section id="topicSix">
            <h2>Métodos e Propriedadas da String:</h2>
            <p>
                A String é um tipo de dado primitivo que representa uma sequência de caracteres. Ele é utilizado para armazenar e manipular 
                textos. Além disso, a classe String possui diversos métodos que permitem a manipulação e análise dessas sequências de 
                caracteres. Os principais e mais utilizados deles são:
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const firstString = 'Olá ';</pre>
                    <pre>const lastString = 'mundo!';</pre><br>
                    <pre>console.log(firstString.length) <span class="comment">// Irá retorna a quantidade de caracteres.</span></pre>
                    <pre>console.log(firstString.charAt(1)) <span class="comment">// Irá retornar o caracter na posição passada.</span></pre>
                    <pre>console.log(firstString.toLowerCase()) <span class="comment">// Irá deixar todos os caracteres minúsculos.</span></pre>
                    <pre>console.log(firstString.toUpperCase()) <span class="comment">// Irá deixar todos os caracteres maiusculos.</span></pre>
                    <pre>console.log(firstString.endsWith('lá')) <span class="comment">// Irá verificar se a String termina com o valor passado.</span></pre>
                    <pre>console.log(firstString.startsWith('Ol')) <span class="comment">// Irá verificar se a String começa com o valor passado.</span></pre>
                    <pre>console.log(firstString.includes(' ')) <span class="comment">// Irá verificar se a String contem o valor passado.</span></pre>
                    <pre>console.log(firstString.concat(lastString)) <span class="comment">// Irá concatenar as duas Strings</span></pre>
                    <pre>console.log(lastString.substring(1, 3)) <span class="comment">// Irá pegar um pedaço da String, através das posições inicial e final passado.</span></pre>
                    <pre>console.log(lastString.slice(-3, -1)) <span class="comment">// Irá pegar um pedaço da String igual anteriormente, porém de trás para frente.</span></pre>
                    <pre>console.log(firstString.padStart(5, '*')) <span class="comment">// Irá aumentar a quantidade de caracteres e completar o início com o valor passado.</span></pre>
                    <pre>console.log(firstString.padEnd(5, '*')) <span class="comment">// Irá aumentar a quantidade de caracteres e completar o final com o valor passado </span></pre>
                    <pre>console.log(firstString.split(' ')) <span class="comment">// Irá dividir a String onde houver o caracter passado e adiciona-las em listas separadas.</span></pre>
                    <pre>console.log(firstString.replace('O', 'A')) <span class="comment">// Irá substituir a primeira ocorrência do valor especificado.</span></pre>
                </code>
            </div>
        </section>
        <section id="topicSeven">
            <h2>Métodos e Propriedades do Array:</h2>
            <p>
                O array é um tipo de lista onde são armazenado elementos chamados de itens, podendo esses ser manipulados como desejar através 
                dos métodos do array. Os principais métodos de manipulação de array e seus itens são:
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const array = ['gol', 'hb20', 'hilux', 'gol']</pre>
                    <pre>const array2 = ['gol', 'hb20', 'hilux', 'gol']</pre><br>
                    <pre><span class="comment">// Para array comum, declarado:</span></pre>
                    <pre>console.log(array.lenght) <span class="comment">// Irá ler a quantidade de elementos no array</span></pre>
                    <pre>console.log(array.unshift('gol quadrado')) <span class="comment">// Adicionará um novo item no início do array</span></pre>
                    <pre>console.log(array.shift()) <span class="comment">// Removerá o primeiro item do array</span></pre>
                    <pre>console.log(array.push('gol quadrado')) <span class="comment">// Adicionará um item no final do array</span></pre>
                    <pre>console.log(array.pop()) <span class="comment">// Removerá o ultimo item do array </span></pre>
                    <pre>console.log(array.includes('hb20')) <span class="comment">// Verificará se um item existe ou não no array</span></pre>
                    <pre>console.log(array.sort()) <span class="comment">// Irá ordenar os itens de um array (numérico/outro)</span></pre>
                    <pre>console.log(array.reverse()) <span class="comment">// Irá inverter os itens do array</span></pre>
                    <pre>console.log(array.indexOf('gol')) <span class="comment">// Pegará o valor passado e verificará sua primeira aparição (index) no array</span></pre>
                    <pre>console.log(array.lastIndexOf('gol')) <span class="comment">// Pegará o valor passado e verificará sua última aparição (index) no array</span></pre>
                    <pre>console.log(array.join()) <span class="comment">// Unirá todos os itens de um array em uma única string separado por "," (padrão)</span></pre>
                    <pre>console.log(array.concat(array2)) <span class="comment">// Irá concatenar dois arrays</span></pre><br>
                    <pre><span class="comment">Para array construtor, métodos estáticos:</span></pre>
                    <pre>console.log(Array.from()) <span class="comment">// Transforma algo parecido com um array em um array realmente</span></pre>
                    <pre>console.log(Array.isArray(array)) <span class="comment">// Verifica se um elemnto é um array ou não, com boolean</span></pre>
                    <pre>console.log(Array.of(1, 2, 3)) <span class="comment">// Uma maneira de construir um array</span></pre>
                    <pre>console.log(new Array(1, 2, 3)) <span class="comment">// Utiliza uma class para contruir um novo array</span></pre>
                    <pre>console.log(Array(1, 2, 3)) <span class="comment">// Outra maneira simples para contruir um novo array</span></pre>
                </code>
            </div>
        </section>
        <section id="topicEigth">
            <h2>Operações com Array:</h2>
            <p>
                Aqui você verá várias operações com arrays em JavaScript: "forEach" itera sobre os itens, "map" cria um novo array 
                transformado, "reduce" acumula valores, "find" e "findIndex" retornam o primeiro valor verdadeiro e sua posição, "some" e 
                "every" verificam condições e "filter" filtra elementos conforme a condição definida.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const pessoas = ['', 'João', 'Maria', 'José', 'Raissa', 'Gaiata', 'Raissa'];</pre>
                    <pre>const frutas = [{nome: 'banana', quantidade: 3}, {nome: 'Imbu', quantidade: 2000}];</pre>
                    <pre>const preco = [3.5, 5, 12, 7.2, 1];</pre><br>
                    <pre><span class="comment">// Itera sobre todos os itens do array</span></pre>
                    <pre>pessoas.forEach((value, index, array) => {</pre>
                    <pre>    console.log(value, index, array);</pre>
                    <pre>});</pre>
                    <pre>frutas.forEach((value, index, array) => {</pre>
                    <pre>    console.log(value.nome, index, array);</pre>
                    <pre>});</pre><br>
                    <pre><span class="comment">// Itera sobre todos os itens do array, podendo este criar um novo array</span></pre>
                    <pre>const returnMap = pessoas.map((value, index) => {</pre>
                    <pre>    return `${value} ${index}`</pre>
                    <pre>})</pre><br>
                    <pre><span class="comment">// Acumula o valor anterior para interagir com o atual</span></pre>
                    <pre>const returnReduce = preco.reduce((acc, value) => {</pre>
                    <pre>    return acc + value</pre>
                    <pre>}, 0) <span class="comment">// 0 é o acumulado inicial</span></pre><br>
                    <pre><span class="comment">// Retorna o primeiro valor verdadeiro do array</span></pre>
                    <pre>const returnFind = pessoas.find((value) => value)</pre><br>
                    <pre><span class="comment">// Retorna a posição do primeiro valor verdadeiro do array</span></pre>
                    <pre>const returnoFindIndex = pessoas.findIndex((value) => value)</pre><br>
                    <pre><span class="comment">// Retorna true quando existir um valor true e false quando todos forem false</span></pre>
                    <pre>const returnoSome = pessoas.some((value) => value)</pre><br>
                    <pre><span class="comment">// Retorna true quando todos os valores forem true e false quando ao menos um for false</span></pre>
                    <pre>const returnEvery = pessoas.every((value) => value)</pre><br>
                    <pre><span class="comment">// Retorna o valor especificado</span></pre>
                    <pre>const returnFilter = pessoas.filter((value) => value === 'Raissa')</pre>
                </code>
            </div>
        </section>
        <section id="topicNine">
            <h2>Métodos e Propriedades da Função:</h2>
            <p>
                Em JavaScript, funções possuem propriedades como length, que indica a quantidade de parâmetros, e name, que retorna seu nome. 
                Além disso, métodos como call e apply permitem definir o contexto de this, passando argumentos individualmente ou em um array. 
                Já o bind retorna uma nova função com o contexto e argumentos pré-definidos, oferecendo mais controle sobre sua execução.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Propriedades</span></pre>
                    <pre>function functionOne(name, age) {</pre>
                    <pre>   console.log(name, age);</pre>
                    <pre>}</pre>
                    <pre>function functionTwo(name, age) {</pre>
                    <pre>   console.log(name, age, this.profissao);</pre>
                    <pre>}</pre><br>
                    <pre><span class="comment">// Length</span></pre>
                    <pre>functionOne.length; <span class="comment">// retorna 2, a quantidade de parâmetros</span></pre>
                    <pre>functionOne.name; <span class="comment">// retorna o nome da função</span></pre><br>
                    <pre><span class="comment">// Principais Métodos</span></pre>
                    <pre><span class="comment">// Jeito comum de executar uma função</span></pre>
                    <pre>functionOne('Diogo', 20);</pre><br>
                    <pre><span class="comment">// Executa a função podendo passar um novo valor para "this"</span></pre>
                    <pre>functionTwo.call({profissao: 'Programador'}, 'Diogo', 20);</pre><br>
                    <pre><span class="comment">// Tem a mesma função do "Call", porém esta passa os valores através de array</span></pre>
                    <pre>functionTwo.apply({profissao: 'Programador'}, ['Diogo', 20]);</pre><br>
                    <pre><span class="comment">// Retorna a função com os valores já passados</span></pre>
                    <pre>const newFunction = functionTwo.bind({profissao: 'Programador'}, 'Diogo', 20);</pre>
                    <pre>newFunction();</pre>
                </code>
            </div>
        </section>
        <section id="topicTen">
            <h2>Métodos e Propriedades do Objeto:</h2>
            <p>
                Em JavaScript, é possível transferir propriedades entre objetos usando "Object.assign()" ou a sintaxe de spread (...). O 
                "Object.assign()" copia as propriedades de objeto2 para objeto1, enquanto o spread cria um novo objeto, combinando as 
                propriedades de ambos os objetos, e adicionando novas se necessário. Além disso, "Object.keys()" retorna todas as chaves de 
                um objeto em um array, enquanto "Object.values()" retorna um array com os valores dessas chaves. Esses métodos oferecem 
                formas práticas de manipulação de objetos.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Propriedades</span></pre>
                    <pre>const objeto1 = {</pre>
                    <pre>    nome: 'Paulo',</pre>
                    <pre>    idade: '20'</pre>
                    <pre>}</pre>
                    <pre>const objeto2 = {</pre>
                    <pre>    idade: '22'</pre>
                    <pre>}</pre><br>
                    <pre><span class="comment">// Permite transferir propriedades e métodos entre objetos</span></pre>
                    <pre>Object.assign(objeto1, objeto2);</pre>
                    <pre>console.log(objeto1);</pre><br>
                    <pre><span class="comment">// Outra forma de fazer essa transferência é com Rest</span></pre>
                    <pre>const objeto3 = {</pre>
                    <pre>    ...objeto1,</pre>
                    <pre>    ...objeto2,</pre>
                    <pre>    cidade: 'Brejo Santo'</pre>
                    <pre>};</pre><br>
                    <pre><span class="comment">// Retorna um array com todas as chaves do objeto</span></pre>
                    <pre>console.log(Object.keys(objeto1));</pre><br>
                    <pre><span class="comment">// Retorna um array com todos os valores do objeto</span></pre>
                    <pre>console.log(Object.values(objeto2));</pre>                        
                </code>
            </div>
        </section>
        <section id="topicEleven">
            <h2>Métodos e Propriedades de Number, Math e Date:</h2>
            <p>
                Em JavaScript é possível trabalhar com números, matemática e datas de forma nativa. Podemos converte strings para números 
                com "Number.parseFloate" e "Number.parseInt", para transformar números em strings com "toString" e arredondar valores com 
                "toFixed". Utilizando Math, realizar operações matemáticas como arredondamento (ceil, floor, round), valor absoluto (abs), 
                geração de números aleatórios (random), além de encontrar o maior (max) e menor (min) número. Por fim, o uso de Date permite 
                obter informações como dia, mês, ano, hora e minuto do sistema.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const number = 10;</pre>
                    <pre>const string = '20.5';</pre>
                    <pre>const breakNumber = 10.8;</pre><br>
                    <pre><span class="comment">// Retorna um número a partir de uma string</span></pre>
                    <pre>console.log(Number.parseFloat(string));</pre>
                    <pre><span class="comment">// Retorna um número inteiro a partir de uma string, contém diferentes tipos de base</span></pre>
                    <pre>console.log(Number.parseInt(string));</pre>
                    <pre><span class="comment">// Retorna uma string a partir de um número</span></pre>
                    <pre>console.log(number.toString());</pre>
                    <pre><span class="comment">// Arredonda um número com base na casa decimal</span></pre>
                    <pre>console.log(breakNumber.toFixed());</pre><br>
                    <pre><span class="comment">// Math: nativo do JS e traz métodos e propriedades de expressões matemáticas</span></pre>
                    <pre><span class="comment">// Retorna o valor absoluto do número</span></pre>
                    <pre>console.log(Math.abs(-5));</pre>
                    <pre><span class="comment">// Arredonda o valor para uma casa acima</span></pre>
                    <pre>console.log(Math.ceil(4.3));</pre>
                    <pre><span class="comment">// Arredonda o valor para uma casa abaixo</span></pre>
                    <pre>console.log(Math.floor(4.7));</pre>
                    <pre><span class="comment">// Arredonda o valor para a casa mais próxima</span></pre>
                    <pre>console.log(Math.round(4.5));</pre>
                    <pre><span class="comment">// Retorna um número aleatório entre 0 e 1</span></pre>
                    <pre>console.log(Math.random()); <span class="comment">// Para um leque maior de números, utiliza-se '*' mais o valor máximo (* 100).</span></pre>
                    <pre><span class="comment">// Retorna o maior número entre eles</span></pre>
                    <pre>console.log(Math.max(1, 3, 7, 11)); <span class="comment">// 11</span></pre>
                    <pre><span class="comment">// Retorna o menor número entre eles</span></pre>
                    <pre>console.log(Math.min(1, 3, 7, 11)); <span class="comment">// 1</span></pre>
                    <pre><span class="comment">// Construtor de Datas</span></pre>
                    <pre>const hoje = new Date();</pre><br>
                    <pre><span class="comment">// Retorna o dia atual</span></pre>
                    <pre>console.log(hoje.getDate());</pre>
                    <pre><span class="comment">// Retorna o mês atual</span></pre>
                    <pre>console.log(hoje.getMonth());</pre>
                    <pre><span class="comment">// Retorna o ano atual</span></pre>
                    <pre>console.log(hoje.getFullYear());</pre>
                    <pre><span class="comment">// Retorna a hora atual</span></pre>
                    <pre>console.log(hoje.getHours());</pre>
                    <pre><span class="comment">// Retorna o minuto atual</span></pre>
                    <pre>console.log(hoje.getMinutes());</pre>
                    <pre><span class="comment">// Retorna o dia da semana</span></pre>
                    <pre>console.log(hoje.getDay());</pre>
                </code>
            </div>
        </section>
        <section id="topicTwelve">
            <h2>Escopo:</h2>
            <p>
                O código demonstra o conceito de escopo em JavaScript. Variáveis declaradas fora de funções podem ser acessadas dentro 
                delas, enquanto variáveis declaradas dentro de uma função não são acessíveis externamente. No entanto, "var" ignora o escopo 
                de bloco e pode causar comportamentos indesejados, como no exemplo onde a variável "se", declarada dentro do "if", não está 
                disponível fora da função, resultando em um erro. Isso reforça a importância de usar "let" ou "const" para evitar vazamento 
                de escopo.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>const funcao1 = 'Função';</pre><br>
                    <pre><span class="comment">// Escopo de função</span></pre>
                    <pre>function funcao() {</pre>
                    <pre>    console.log(funcao1);</pre><br>
                    <pre>    <span class="comment">// Escopo de bloco</span></pre>
                    <pre>    if(1) {</pre>
                    <pre>        console.log('Se');</pre>
                    <pre>        var se = 'se'; <span class="comment">// Má prática</span></pre>
                    <pre>    } else {</pre>
                    <pre>        console.log('Se não');</pre>
                    <pre>    }</pre>
                    <pre>}</pre><br>
                    <pre>console.log(se); <span class="comment">// Error</span></pre><br>
                    <pre><span class="comment">// Uma variável criada fora pode ser acessada dentro de uma função</span></pre>
                    <pre><span class="comment">// Já uma variável criada dentro de uma função não pode ser acessada fora, exceto "var"</span></pre>
                </code>
            </div>
        </section>
        <section id="topicThirteen">
            <h2>Promise, Then e Catch:</h2>
            <p>
                A Promise em javascript é a simulação de um processo que pode ser bem sucedido (resolve) ou fracassado (reject) com base em 
                um valor aleatório. O método "then" é chamado quando a promessa é resolvida, enquanto "catch" trata de possíveis erros. Esse 
                mecanismo permite lidar com processos assíncronos de forma estruturada, evitando o aninhamento excessivo de callbacks.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Síncrono: processamento ocorre de forma sequencial</span></pre>
                    <pre><span class="comment">// Assíncrono: podem ocorrer vários processos ao mesmo tempo</span></pre><br>
                    <pre><span class="comment">// Promise: objeto utilizado para operações assíncronas</span></pre>
                    <pre>const minhaPromise = new Promise((resolve, reject) => {</pre>
                    <pre>    <span class="comment">// Gera um resultado booleano</span></pre>
                    <pre>    let sucesso = Math.random() > 0.5;</pre><br>
                    <pre>    <span class="comment">// Executado quando resolvido</span></pre>
                    <pre>    if (sucesso) {</pre>
                    <pre>        resolve('Deu certo! ✅');</pre>
                    <pre>    }</pre>
                    <pre>    <span class="comment">// Executado quando não resolvido</span></pre>
                    <pre>    else {</pre>
                    <pre>        reject('Deu errado! ❌');</pre>
                    <pre>    }</pre>
                    <pre>});</pre><br>
                    <pre>minhaPromise</pre>
                    <pre>    <span class="comment">// Recebe o valor de "resolve"</span></pre>
                    <pre>    .then(result => {</pre>
                    <pre>        console.log(result);</pre>
                    <pre>    })</pre>
                    <pre>    <span class="comment">// Recebe o valor de "reject"</span></pre>
                    <pre>    .catch(error => {</pre>
                    <pre>        console.log(error);</pre>
                    <pre>    });</pre>
                </code>
            </div>
        </section>
        <section id="topicFourteen">
            <h2>Fetch:</h2>
            <p>
                O método "fetch" é uma ferramenta essencial do JavaScript para realizar requisições HTTP e interagir com APIs, permitindo a 
                comunicação entre o Front-End e o Back-End. Ele segue um fluxo de interação onde os dados são solicitados ou enviados 
                através de um endpoint, que serve como ponte entre o cliente e o servidor.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Fetch: é um método que retorna uma promise via HTTP</span></pre>
                    <pre><span class="comment">// HTTP: é o caminho que direciona ao local da promise</span></pre>
                    <pre>fetch('https://api.coingecko.com/api/v3/exchange_rates', {mode: 'cors'})</pre>
                    <pre>    .then((data) => {</pre>
                    <pre>        console.log(data);</pre>
                    <pre>    });</pre>
                </code>
            </div>
            <p>
                As requisições utilizam verbos HTTP, como GET, POST, PUT e PATCH e DELETE, seguindo o padrão CRUD (Create, Read, Update, 
                Delete). O retorno dessas requisições é tratado com .then( ) para capturar os dados recebidos e .catch( ) para lidar com 
                possíveis erros.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// GET: Para solicitar um dado</span></pre>
                    <pre><span class="comment">// POST: Para enviar um dado</span></pre>
                    <pre><span class="comment">// DELETE: Para deletar um dado</span></pre>
                    <pre><span class="comment">// PUT: Para um dado específico</span></pre>
                    <pre><span class="comment">// PATCH: Para alterar múltiplos dados</span></pre>
                </code>
            </div>
            <p>
                Além disso, é possível personalizar as requisições para tornar a comunicação mais flexível e eficiente com os 4 parâmetros de
                uma requisição HTTP, Route Params, Query Params, Body Params e Header Params.
            </p>
            <h4>Estrutura padrão Fetch:</h4>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre>fetch('https://api.coingecko.com/api/v3/exchange_rates/routeParams') <span class="comment">// Route params</span></pre>
                    <pre><span class="comment">//...</span></pre>
                    <pre>fetch('https://api.coingecko.com/api/v3/exchange_rates?query=params'), <span class="comment">// Query params</span></pre>
                    <pre>{  mode: 'cors',</pre>
                    <pre>  method: GET, <span class="comment">// Método</span></pre>
                    <pre>  body: {name: 'Diogo', age: '20'}, <span class="comment">// Body params</span></pre>
                    <pre>  headers: {inforcoes: 'extras'}, <span class="comment">// Header params</span></pre>
                </code>
            </div>
            <h4>Status HTTP:</h4>
            <p>
                Além dessas informações podemos definir e receber feedbacks sobre o estado dessas informações, verificar se uma requisição 
                foi bem sucedida, se foi redirecionada, se houve erro... Para isso define-se os seguintes status: de 200 - 299 (Sucesso), 
                300 - 399 (Redirecionado), 400 - 499 (Erro no client), 500 - 599 (Erro no server).
            </p>
        </section>
        <section id="topicFifteen">
            <h2>JSON:</h2>
            <p>
                O JSON (Javascript Object Notation) é um formato otimizado de organização de dados. A diferença do JSON para o objeto em JS 
                é que a chave deve sempre estar em formato string. É comum também de ser utilizado como extensão de arquivos, normalmente 
                para os de configuração.
            </p>
            <div class="card">
                <span class="comment">[ js ]</span>
                <code>
                    <pre><span class="comment">// Objeto JS:</span></pre>
                    <pre>const OBJ = {</pre>
                    <pre>    nome: 'Diogo',</pre>
                    <pre>    age: 20</pre>
                    <pre>};</pre><br>
                    <pre><span class="comment">// JSON:</span></pre>
                    <pre>const JSON = '{"nome": "Diogo", "age": 20}';</pre><br>
                    <pre><span class="comment">// Métodos JSON:</span></pre>
                    <pre><span class="comment">// Transforma um objeto Javascript em uma string JSON</span></pre>
                    <pre>JSON.stringify(OBJ);</pre><br>
                    <pre><span class="comment">// Transforma uma string JSON em objeto Javascript</span></pre>
                    <pre>JSON.parse(JSON);</pre>
                </code>
            </div>
        </section>
        <section id="exercise">
            <h2>Página de Exercícios:</h2>
            <p>
                Link diredionado a página de execução de arquivos de exercício sobre JavaScript Básico Intermediário
                <b><a href="../exercises/exeModuleThree/intermediateJavaScript.html" target="_blank"> aqui!</a></b>.
            </p>
        </section>
        <!--End of Container Here-->
    </main>
    <footer>
        <p class="textAlignCenter">
            <small>&copy; 2024 Diogo Gabriel - <b>Desenvolvido para compartilhar conhecimento sobre programação e design web</b>. Todos os 
            direitos reservados.</small>
        </p>
    </footer>
</body>
</html>